# SPDX-FileCopyrightText: 2025 Rayleigh Research <to@rayleigh.re>
# SPDX-License-Identifier: MIT
from pydantic import BaseModel
from taos.im.protocol.simulator import *
from taos.common.protocol import SimulationEvent

"""
Classes representing events occurring in the simulation are defined here.
"""

class FinanceEvent(SimulationEvent):
    """
    Base class for representing market events occurring in the simulation.
    """
    @classmethod
    def from_simulator(self, message : SimulatorAgentMessage):
        """
        Method to transform agent event messages generated by simulator to the format required by the MarketSimulationStateUpdate synapse.
        """
        match message.type:
            case "EVENT_SIMULATION_START":
                return SimulationStartEvent.from_simulator(message)
            case "RESPONSE_DISTRIBUTED_PLACE_ORDER_LIMIT" | "ERROR_RESPONSE_DISTRIBUTED_PLACE_ORDER_LIMIT":
                return LimitOrderPlacementEvent.from_simulator(message)
            case "RESPONSE_DISTRIBUTED_PLACE_ORDER_MARKET" | "ERROR_RESPONSE_DISTRIBUTED_PLACE_ORDER_MARKET":
                return MarketOrderPlacementEvent.from_simulator(message)
            case "EVENT_TRADE":
                return TradeEvent.from_simulator(message)
            case "RESPONSE_DISTRIBUTED_CANCEL_ORDERS" | "ERROR_RESPONSE_DISTRIBUTED_CANCEL_ORDERS":
                return OrderCancellationsEvent.from_simulator(message)
            case "RESPONSE_DISTRIBUTED_RESET_AGENT" | "ERROR_RESPONSE_DISTRIBUTED_RESET_AGENT":
                return ResetAgentsEvent.from_simulator(message)
            case "EVENT_SIMULATION_STOP":
                return SimulationEndEvent.from_simulator(message)

class SimulationStartEvent(FinanceEvent):
    """
    Represents the event generated on simulation start.

    Attributes:
    - logDir: The directory where simulation outputs are recorded by the simulator.
    """
    logDir : str
    @classmethod
    def from_simulator(self, message : SimulatorAgentMessage):
        """
        Method to transform simulator format event message to the format required by the MarketSimulationStateUpdate synapse.
        """
        return SimulationStartEvent(
            type=message.type, timestamp=message.timestamp, agentId=None, logDir=message.payload['logDir']
        )
        
    def __str__(self):
        return f"SIMULATION STARTED!"

class SimulationEndEvent(FinanceEvent):
    """
    Represents the event generated on simulation end.
    """
    @classmethod
    def from_simulator(self, message : SimulatorAgentMessage):
        """
        Method to transform simulator format event message to the format required by the MarketSimulationStateUpdate synapse.
        """
        return SimulationEndEvent(
            type=message.type, timestamp=message.timestamp, agentId=None
        )
        
    def __str__(self):
        return f"SIMULATION ENDED!"

class OrderPlacementEvent(FinanceEvent):
    """
    Base class for representing events corresponding to placement of a order in the simulation.

    Attributes:
    - bookId: The id of the orderbook on which the order was attempted to be placed.
    - orderId: The id assigned to the order by the simulator.
    - clientOrderId: Optional agent-assigned identifier for the order.
    - side: The side of the book on which the order  was attempted to be placed (0=BID, 1=ASK).
    - quantity: The size of the order in base currency.
    - success: Flag indicating if the order was successfully placed or not.
    - message: The message associated with the failure in the case of unsuccessful placement.
    """
    bookId : int | None = None
    orderId : int | None
    clientOrderId : int | None
    side : int
    quantity : float
    success : bool
    message : str

class LimitOrderPlacementEvent(OrderPlacementEvent):
    """
    Represents the event generated on placement of a Limit Order in the simulation.

    Attributes:
    - price: The price level at which the order was attempted to beplaced.
    """
    price : float
    @classmethod
    def from_simulator(self, message : SimulatorAgentMessage):
        """
        Method to transform simulator format event message to the format required by the MarketSimulationStateUpdate synapse.
        """
        if message.type == 'RESPONSE_DISTRIBUTED_PLACE_ORDER_LIMIT':
            return LimitOrderPlacementEvent(
                type=message.type, timestamp=message.timestamp, agentId=message.payload['agentId'],
                bookId=message.payload['payload']['requestPayload']['bookId'],
                orderId=message.payload['payload']['orderId'],clientOrderId=message.payload['payload']['requestPayload']['clientOrderId'],
                side=message.payload['payload']['requestPayload']['direction'],
                price=message.payload['payload']['requestPayload']['price'],quantity=message.payload['payload']['requestPayload']['volume'],
                success=True,message=f"{'Buy' if message.payload['payload']['requestPayload']['direction'] == 0 else 'Sell'} Limit Order {message.payload['payload']['orderId']} placed successfully for {message.payload['payload']['requestPayload']['volume']}@{message.payload['payload']['requestPayload']['price']}!"
            )
        elif message.type == 'ERROR_RESPONSE_DISTRIBUTED_PLACE_ORDER_LIMIT':
            return LimitOrderPlacementEvent(
                type=message.type, timestamp=message.timestamp, agentId=message.payload['agentId'],
                bookId=message.payload['payload']['requestPayload']['bookId'],
                orderId=None,clientOrderId=message.payload['payload']['requestPayload']['clientOrderId'],
                side=message.payload['payload']['requestPayload']['direction'],
                price=message.payload['payload']['requestPayload']['price'],quantity=message.payload['payload']['requestPayload']['volume'],
                success=False,message=message.payload['payload']['errorPayload']['message']
            )
        
    def __str__(self):
        return f"{'PLACED' if self.success else 'FAILED TO PLACE'} {'BUY ' if self.side == 0 else 'SELL'} LIMIT ORDER{' #'+str(self.orderId) if self.orderId else ''}{' ('+self.clientOrderId+')' if self.clientOrderId else ''} FOR {self.quantity}@{self.price} AT T={self.timestamp}{' : ' + self.message if not self.success else ''}"
        
class MarketOrderPlacementEvent(OrderPlacementEvent):
    """
    Represents the event generated on placement of a Market Order in the simulation.
    """
    @classmethod
    def from_simulator(self, message : SimulatorAgentMessage):
        """
        Method to transform simulator format event message to the format required by the MarketSimulationStateUpdate synapse.
        """
        if message.type == 'RESPONSE_DISTRIBUTED_PLACE_ORDER_MARKET':
            return MarketOrderPlacementEvent(
                type=message.type, timestamp=message.timestamp, agentId=message.payload['agentId'],
                bookId=message.payload['payload']['requestPayload']['bookId'],
                orderId=message.payload['payload']['orderId'],clientOrderId=message.payload['payload']['requestPayload']['clientOrderId'],
                side=message.payload['payload']['requestPayload']['direction'],quantity=message.payload['payload']['requestPayload']['volume'],
                success=True,message=f"{'Buy' if message.payload['payload']['requestPayload']['direction'] == 0 else 'Sell'} Market Order {message.payload['payload']['orderId']} placed successfully for {message.payload['payload']['requestPayload']['volume']}!"
            )
        elif message.type == 'ERROR_RESPONSE_DISTRIBUTED_PLACE_ORDER_MARKET':
            return MarketOrderPlacementEvent(
                type=message.type, timestamp=message.timestamp, agentId=message.payload['agentId'],
                bookId=message.payload['payload']['requestPayload']['bookId'],
                orderId=None,clientOrderId=message.payload['payload']['requestPayload']['clientOrderId'],
                side=message.payload['payload']['requestPayload']['direction'],quantity=message.payload['payload']['requestPayload']['volume'],
                success=False,message=message.payload['payload']['errorPayload']['message']
            )
        
    def __str__(self):
        return f"{'PLACED' if self.success else 'FAILED TO PLACE'} {'BUY ' if self.side == 0 else 'SELL'} MARKET ORDER{' #'+str(self.orderId) if self.orderId else ''}{' ('+self.clientOrderId+')' if self.clientOrderId else ''} FOR {self.quantity} AT T={self.timestamp}{' : ' + self.message if not self.success else ''}"
        
class OrderCancellationEvent(BaseModel):
    """
    Represents cancellation of a single order.

    Attributes:
    - timestamp: The timestamp at which cancellation was attempted.
    - bookId: The id of the orderbook on which the order was attempted to be cancelled.
    - orderId: The id of the order attempted to be cancelled.
    - quantity: The quantity of the order to be cancelled, in base currency.  If `None`, the whole remaining size of the order is cancelled.
    - success: Flag indicating if the order was successfully cancelled or not.
    - message: The message associated with the failure in the case of unsuccessful cancellation.
    """
    timestamp : int
    bookId : int
    orderId : int
    quantity : float | None
    success : bool
    message : str

    def __str__(self):
        return f"{'CANCELLED' if self.success else 'FAILED TO CANCEL'} ORDER #{self.orderId}{' FOR ' + str(self.quantity) if self.quantity else ''} AT T={self.timestamp}{' : ' + self.message if not self.success else ''}"
        
class OrderCancellationsEvent(FinanceEvent):
    """
    Represents the event generated on cancellation of a list of orders.

    Attributes:
    - bookId: The id of the orderbook on which the orders were attempted to be cancelled.
    - cancellations: A list of OrderCancellationEvent objects representing the individual order cancellation events.
    """
    bookId : int | None = None
    cancellations : list[OrderCancellationEvent] = []
    @classmethod
    def from_simulator(self, message : SimulatorAgentMessage):
        """
        Method to transform simulator format event message to the format required by the MarketSimulationStateUpdate synapse.
        """
        event = OrderCancellationsEvent(type=message.type, timestamp=message.timestamp, agentId=message.payload['agentId'], bookId=message.payload['payload']['requestPayload']['bookId'])
        if message.type == 'RESPONSE_DISTRIBUTED_CANCEL_ORDERS':
            for cancellation in message.payload['payload']['requestPayload']['cancellations']:
                event.cancellations.append(
                    OrderCancellationEvent( timestamp=event.timestamp,
                        bookId=event.bookId, orderId=cancellation['orderId'],quantity=cancellation['volume'],
                        success=True,message=f"Cancelled order {cancellation['orderId']} on book {event.bookId} for agent {event.agentId}."
                    )
                )
        elif message.type == 'ERROR_RESPONSE_DISTRIBUTED_CANCEL_ORDERS':
            for cancellation in message.payload['payload']['requestPayload']['cancellations']:
                event.cancellations.append(
                    OrderCancellationEvent( timestamp=event.timestamp,
                        bookId=event.bookId, orderId=cancellation['orderId'],quantity=cancellation['volume'],
                        success=False,message=f"Order Id does not exist!"
                    )
                )
        return event
    
    def __str__(self):
        return "\n".join([f"{c}" for c in self.cancellations])
    
class TradeEvent(FinanceEvent):
    """
    Represents the event generated on execution of trade in the simulation.

    Attributes:
    - bookId: The id of the orderbook on which the trade occurred.
    - tradeId: The id of the trade as assigned by the simulator.
    - clientOrderId: Optional agent-assigned identifier for the resting order which was traded.
    - takerAgentId: The id of the agent which initiated the trade (aggressor).
    - takerOrderId: The id of the aggressing order involved in the trade.
    - makerAgentId: The id of the agent which placed the resting order involved in the trade.
    - makerOrderId: The id of the resting order involved in the trade.
    - side: The direction in which the trade occurred; if the trade was buy initiated side=0, otherwise side=1
    - price: The price level at which the trade occurred.
    - quantity: The quantity traded in base currency.
    """
    bookId : int | None = None
    tradeId : int
    clientOrderId : int | None
    takerAgentId : int
    takerOrderId : int
    makerAgentId : int
    makerOrderId : int
    side : int
    price : float
    quantity : float
    makerFee : float
    takerFee : float
    @classmethod
    def from_simulator(self, message : SimulatorAgentMessage):
        """
        Method to transform simulator format event message to the format required by the MarketSimulationStateUpdate synapse.
        """
        return TradeEvent(
            type=message.type, timestamp=message.timestamp, agentId=message.payload['agentId'],
            bookId=message.payload['payload']['bookId'], tradeId=message.payload['payload']['trade']['tradeId'], 
            clientOrderId=message.payload['payload']['clientOrderId'],
            takerAgentId=message.payload['payload']['context']['aggressingAgentId'], takerOrderId=message.payload['payload']['trade']['aggressingOrderId'],
            makerAgentId=message.payload['payload']['context']['restingAgentId'], makerOrderId=message.payload['payload']['trade']['restingOrderId'],
            side=message.payload['payload']['trade']['direction'],price=message.payload['payload']['trade']['price'],quantity=message.payload['payload']['trade']['volume'],
            makerFee=message.payload['payload']['context']['fees']['maker'], takerFee=message.payload['payload']['context']['fees']['taker']
        )
    
    def __str__(self):
        return f"{'BUY ' if self.side == 0 else 'SELL'} TRADE #{self.tradeId} : RESTING ORDER #{self.makerOrderId} (AGENT {self.makerAgentId}) MATCHED AGAINST #{self.takerOrderId} (AGENT {self.takerAgentId}) FOR {self.quantity}@{self.price} AT T={self.timestamp}"
    

class ResetAgentEvent(FinanceEvent):
    """
    Represents the event generated when a single agent account is reset (requested by validator on deregistration).

    Attributes:
    - agentId: The id of the agent whose accounts were reset.
    - success: Flag indicating if the agent's accounts was successfully reset or not.
    - message: The message associated with the failure in the case of unsuccessful reset.
    """
    success : bool
    message : str
    
    def __str__(self):
        return f"{'RESET' if self.success else 'FAILED TO RESET'} AGENT #{self.agentId} AT T={self.timestamp}{' : ' + self.message if not self.success else ''}"

class ResetAgentsEvent(FinanceEvent):
    """
    Represents the event generated on reset of a list of agents.

    Attributes:
    - resets: A list of ResetAgentEvent objects representing the individual agent reset events.
    """
    resets : list[ResetAgentEvent] = []
    @classmethod
    def from_simulator(self, message : SimulatorAgentMessage):
        """
        Method to transform simulator format event message to the format required by the MarketSimulationStateUpdate synapse.
        """
        event = ResetAgentsEvent(type=message.type, timestamp=message.timestamp, agentId=message.payload['agentId'])
        if message.type == 'RESPONSE_DISTRIBUTED_RESET_AGENT':
            for agentId in message.payload['payload']['agentIds']:
                event.resets.append(
                    ResetAgentEvent(
                        type=message.type,
                        timestamp=message.timestamp,
                        agentId=agentId,
                        success=True,
                        message=f"Proxy agent {event.agentId} successfully reset balances for agent {agentId}."
                    )
                )
        elif message.type == 'ERROR_RESPONSE_DISTRIBUTED_RESET_AGENT':
            for agentId in message.payload['payload']['agentIds']:
                event.resets.append(
                    ResetAgentEvent(
                        type=message.type,
                        timestamp=message.timestamp,
                        agentId=agentId,
                        success=False,
                        message=f"Proxy agent {event.agentId} failed to reset balance for agent {agentId} : Agent Id does not exist!"
                    )
                )
        return event 
    
    def __str__(self):
        return "\n".join([f"{r}" for r in self.resets])