# SPDX-FileCopyrightText: 2025 Rayleigh Research <to@rayleigh.re>
# SPDX-License-Identifier: MIT
import zlib
import json
import time
import pybase64
import msgspec
import bittensor as bt
from typing import Optional, ClassVar
from enum import Enum
from taos.im.protocol.simulator import *
from taos.im.protocol.models import *
from taos.common.protocol import SimulationStateUpdate, EventNotification
from taos.im.protocol.events import *
from taos.im.protocol.models import Book, Account, Balance, Order
from taos.im.protocol.response import FinanceAgentResponse

"""
The core intelligent market simulation protocol classes are defined here.
These are the classes which inherit from bittensor.synapse, and are the objects which are transmitted between validator and miner via dendrite query calls.
"""

class FinanceEventNotification(EventNotification):
    """
    Base class for intelligent market simulator event notifications.
    """
    @classmethod
    def from_simulator(self, message : SimulatorAgentMessage):
        """
        Method to transform messages from simulator to synapse.
        """
        return FinanceEventNotification(event=FinanceEvent.from_simulator(message))
    
    @classmethod
    def from_json(self, json : dict):
        """
        Method to transform messages from simulator to synapse.
        """
        return FinanceEventNotification(event=FinanceEvent.from_json(json))

class MarketSimulationStateUpdate(SimulationStateUpdate):
    """
    Main class for representing intelligent market simulator state.

    Attributes:
    - timestamp: Simulation timestamp at which the state was recorded.
    - books: A dictionary mapping the ID of the simulated orderbooks to a Book object containing state information.
    - accounts: A dictionary mapping the ID of the agent to a dictionary associating orderbook IDs with the state of the agents accounts relative to each book.
    - notices: A dictionary mapping the ID of an agent to the market events relevant to them which have occurred since the last state update.
    - response : Mutable field to be populated by the miner agent with a response containing instructions to be executed in the simulation.
    """
    timestamp : int
    config : MarketSimulationConfig | str | None = None
    books : dict[int,Book] | str
    accounts : dict[int,dict[int, Account]] | str
    notices : dict[int, list[SimulationStartEvent | LimitOrderPlacementEvent | MarketOrderPlacementEvent | OrderCancellationsEvent | TradeEvent | ResetAgentsEvent | SimulationEndEvent]] | str | None = None
    response: Optional[FinanceAgentResponse] | str = None
    compressed : bool = False    
    
    required_fields: ClassVar[list[str]] = None
    def get_required_fields(self) -> list[str]:
        """
        Get the required fields from the model's JSON schema.
        """
        if not self.required_fields:
            schema = self.__class__.model_json_schema()
            MarketSimulationStateUpdate.required_fields = schema.get("required", [])
        return self.required_fields

    def environment_state(self) -> dict[int, Book]:
        """
        Method returning the state of the simulation environment; in the case of intelligent markets simulation, this is the orderbook state dictionary.
        """
        return self.books

    def agent_state(self) -> dict[int, dict[int, Account]]:
        """
        Method returning the state of the simulation agents; in the case of intelligent markets simulation, this is the accounts dictionary.
        """
        return self.accounts

    @classmethod
    def from_simulator(cls, timestamp, message : SimulatorStateUpdate):
        """
        Method to transform state update message generated by simulator to subnet synapse format.
        """
        model = 'im'
        books = {book.bookId : Book.from_simulator(book) for book in message.books}
        accounts = {}
        for agentId, account in message.accounts.items():
            if agentId >= 0:
                for book_id, balances in enumerate(account.balances.holdings):
                    if not agentId in accounts:
                        accounts[agentId] = {}
                    accounts[agentId][book_id] = Account(
                        agent_id=account.agentId,book_id=book_id,
                        base_balance=Balance(currency='base',total=balances.base.total,free=balances.base.free,reserved=balances.base.reserved),
                        quote_balance=Balance(currency='quote',total=balances.quote.total,free=balances.quote.free,reserved=balances.quote.reserved),
                        orders=[Order.from_account(order) for order in account.orders[book_id]] if account.orders and account.orders[book_id] else [],
                        fees=Fees.from_simulator(account.fees[book_id]) if account.fees else None
                    )
                        
        notices = {uid : [] for uid in [agentId for agentId in message.accounts if agentId >= 0]}
        for notice in message.notices:
            notice = FinanceEventNotification.from_simulator(notice)
            if notice.event.agentId:
                notices[notice.event.agentId].append(notice.event)
            else:
                for uid in [agentId for agentId in message.accounts if agentId >= 0]:
                    notices[uid].append(notice.event)
        notices = {agentId : sorted(agent_notices, key=lambda x: x.timestamp) for agentId, agent_notices in notices.items()}
        return MarketSimulationStateUpdate(timestamp=timestamp,model=model,books=books,accounts=accounts,notices=notices)
    
    @classmethod
    def from_json(cls, json):
        """
        Method to transform state update message generated by simulator to subnet synapse format.
        """
        start = time.time()
        payload = json['payload']
        model = 'im'
        books = {book['bookId'] : Book.from_json(book) for book in payload['books']}
        bt.logging.debug(f"Books populated ({time.time()-start:.4f}s).")
        start = time.time()
        accounts = {}
        for sagentId, account in payload['accounts'].items():
            agentId = int(sagentId)
            if agentId >= 0:
                for book_id, balances in enumerate(account['balances']['holdings']):
                    if not agentId in accounts:
                        accounts[agentId] = {}
                    accounts[agentId][book_id] = Account(
                        agent_id=account['agentId'],book_id=book_id,
                        base_balance=Balance.from_json(currency='BASE', json=balances['base']),
                        quote_balance=Balance.from_json(currency='QUOTE', json=balances['quote']),
                        orders=[Order.from_account(order) for order in account['orders'][book_id]] if account['orders'] and account['orders'][book_id] else [],
                        fees=Fees.from_json(account['fees'][str(book_id)]) if account['fees'] else None
                    )
        bt.logging.debug(f"Accounts populated ({time.time()-start:.4f}s).")
        start = time.time()                        
        notices = {int(uid) : [] for uid in payload['accounts'] if int(uid) >= 0}
        for notice in sorted(payload['notices'], key=lambda x: (x['timestamp'], -x['delay'])):
            notice = FinanceEventNotification.from_json(notice)
            if notice.event.agentId:
                notices[notice.event.agentId].append(notice.event)
            else:
                for uid in [int(agentId) for agentId in payload['accounts'] if int(agentId) >= 0]:
                    notices[uid].append(notice.event)
        notices = {agentId : sorted(agent_notices, key=lambda x: x.timestamp) for agentId, agent_notices in notices.items()}
        bt.logging.debug(f"Notices populated ({time.time()-start:.4f}s).")
        return MarketSimulationStateUpdate(timestamp=json['timestamp'],model=model,books=books,accounts=accounts,notices=notices)
    
    def clear_inputs(self):
        """
        Method to empty state input data fields to prevent unnecessary data transfer from miners.
        """
        self.books = {}
        self.accounts = {}
        self.notices = {}
        return self

    def compress(self):
        """
        Method to compress large synapse fields for transmission over the network.

        Note this method DOES NOT modify the synapse in place, so that the original synapse data can be referenced after sending without requiring decompression.
        """
        try:
            if not self.compressed:
                compressed = self.model_copy()
                if compressed.books != {}:
                    compressed.books = pybase64.b64encode(zlib.compress(msgspec.json.encode({bookId : book.model_dump(mode='json') for bookId, book in compressed.books.items()}))).decode("ascii")
                    compressed.accounts = pybase64.b64encode(zlib.compress(msgspec.json.encode({accountId : {bookId : account.model_dump(mode='json') for bookId, account in accounts.items()} for accountId, accounts in compressed.accounts.items()}))).decode("ascii")
                    compressed.notices = pybase64.b64encode(zlib.compress(msgspec.json.encode({agentId : [notice.model_dump(mode='json') for notice in notices] for agentId, notices in compressed.notices.items()}))).decode("ascii")
                    compressed.config = pybase64.b64encode(zlib.compress(msgspec.json.encode(compressed.config.model_dump(mode='json')))).decode("ascii")
                if compressed.response:
                    compressed.response = pybase64.b64encode(zlib.compress(msgspec.json.encode(compressed.response.model_dump(mode='json')))).decode("ascii")
                compressed.compressed = True
                return compressed
            else:
                return self
        except Exception as ex:
            bt.logging.error(f"Failed to compress {self.name} synapse data! {ex}")
            return None

    def decompress(self):
        """
        Method to decompress large synapse fields after transmission over the network.

        Note this method DOES modify the synapse in place, so that the synapse can be used normally after decompression.
        """
        try:
            if self.compressed:
                if self.books != {}:
                    self.books = msgspec.json.decode(zlib.decompress(pybase64.b64decode(self.books)))
                    self.accounts = msgspec.json.decode(zlib.decompress(pybase64.b64decode(self.accounts)))
                    self.notices = msgspec.json.decode(zlib.decompress(pybase64.b64decode(self.notices)))
                    self.config = msgspec.json.decode(zlib.decompress(pybase64.b64decode(self.config)))
                if self.response:
                    self.response = msgspec.json.decode(zlib.decompress(pybase64.b64decode(self.response)))
                self.compressed = False
            return self
        except Exception as ex:
            bt.logging.error(f"Failed to decompress {self.name} synapse data! {ex}")
            return None