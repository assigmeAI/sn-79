# SPDX-FileCopyrightText: 2025 Rayleigh Research <to@rayleigh.re>
# SPDX-License-Identifier: MIT
import zlib
import lz4.frame
import time
import pybase64
import msgspec
import bittensor as bt
from typing import Optional, ClassVar, Literal
from taos.im.protocol.simulator import *
from taos.im.protocol.models import *
from taos.common.protocol import SimulationStateUpdate, EventNotification
from taos.im.protocol.events import *
from taos.im.protocol.models import Book, Account, Balance, Order
from taos.im.protocol.response import FinanceAgentResponse
from taos.im.utils.compress import compress

"""
The core intelligent market simulation protocol classes are defined here.
These are the classes which inherit from bittensor.synapse, and are the objects which are transmitted between validator and miner via dendrite query calls.
"""

class FinanceEventNotification(EventNotification):
    """
    Base class for intelligent market simulator event notifications.
    """    
    @classmethod
    def from_json(self, json : dict):
        """
        Method to transform messages from simulator to synapse.
        """
        return FinanceEventNotification(event=FinanceEvent.from_json(json))

class MarketSimulationStateUpdate(SimulationStateUpdate):
    """
    Main class for representing intelligent market simulator state.

    Attributes:
    - timestamp: Simulation timestamp at which the state was recorded.
    - books: A dictionary mapping the ID of the simulated orderbooks to a Book object containing state information.
    - accounts: A dictionary mapping the ID of the agent to a dictionary associating orderbook IDs with the state of the agents accounts relative to each book.
    - notices: A dictionary mapping the ID of an agent to the market events relevant to them which have occurred since the last state update.
    - response : Mutable field to be populated by the miner agent with a response containing instructions to be executed in the simulation.
    """
    timestamp : int
    config : MarketSimulationConfig | str | None = None
    books : dict[int,Book] | None = None
    accounts : dict[int,dict[int, Account]] | None = None
    notices : dict[int, list[SimulationStartEvent | LimitOrderPlacementEvent | MarketOrderPlacementEvent | OrderCancellationsEvent | TradeEvent | ResetAgentsEvent | SimulationEndEvent]] | None = None
    response: Optional[FinanceAgentResponse] | None  = None
    compressed : str | dict | None = None
    compression_engine : str = "zlib"
    
    required_fields: ClassVar[list[str]] = None
    def get_required_fields(self) -> list[str]:
        """
        Get the required fields from the model's JSON schema.
        """
        if not self.required_fields:
            schema = self.__class__.model_json_schema()
            MarketSimulationStateUpdate.required_fields = schema.get("required", [])
        return self.required_fields

    def environment_state(self) -> dict[int, Book]:
        """
        Method returning the state of the simulation environment; in the case of intelligent markets simulation, this is the orderbook state dictionary.
        """
        return self.books

    def agent_state(self) -> dict[int, dict[int, Account]]:
        """
        Method returning the state of the simulation agents; in the case of intelligent markets simulation, this is the accounts dictionary.
        """
        return self.accounts
    
    @classmethod
    def from_json(cls, json):
        """
        Method to transform state update message generated by simulator to subnet synapse format.
        """
        start = time.time()
        payload = json['payload']
        model = 'im'
        books = {book['bookId'] : Book.from_json(book) for book in payload['books']}
        bt.logging.debug(f"Books populated ({time.time()-start:.4f}s).")
        start = time.time()
        accounts = {}
        for sagentId, account in payload['accounts'].items():
            agentId = int(sagentId)
            if agentId >= 0:
                for book_id, balances in enumerate(account['balances']['holdings']):
                    if not agentId in accounts:
                        accounts[agentId] = {}
                    accounts[agentId][book_id] = Account(
                        agent_id=account['agentId'],book_id=book_id,
                        base_balance=Balance.from_json(currency='BASE', json=balances['base']),
                        quote_balance=Balance.from_json(currency='QUOTE', json=balances['quote']),
                        orders=[Order.from_account(order) for order in account['orders'][book_id]] if account['orders'] and account['orders'][book_id] else [],
                        fees=Fees.from_json(account['fees'][str(book_id)]) if account['fees'] else None
                    )
        bt.logging.debug(f"Accounts populated ({time.time()-start:.4f}s).")
        start = time.time()                        
        notices = {int(uid) : [] for uid in payload['accounts'] if int(uid) >= 0}
        for notice in sorted(payload['notices'], key=lambda x: (x['timestamp'], -x['delay'])):
            notice = FinanceEventNotification.from_json(notice)
            if notice.event.agentId:
                notices[notice.event.agentId].append(notice.event)
            else:
                for uid in [int(agentId) for agentId in payload['accounts'] if int(agentId) >= 0]:
                    notices[uid].append(notice.event)
        notices = {agentId : sorted(agent_notices, key=lambda x: x.timestamp) for agentId, agent_notices in notices.items()}
        bt.logging.debug(f"Notices populated ({time.time()-start:.4f}s).")
        return MarketSimulationStateUpdate(timestamp=json['timestamp'],model=model,books=books,accounts=accounts,notices=notices)
    
    def clear_inputs(self):
        """
        Method to empty state input data fields to prevent unnecessary data transfer from miners.
        """
        self.books = {}
        self.accounts = {}
        self.notices = {}
        self.config = None
        return self

    def compress(self, level=-1, engine : Literal["zlib", "lz4"] | None = None, compressed_books : str = None):
        """
        Method to compress large synapse fields for transmission over the network.

        Note this method DOES NOT modify the synapse in place, so that the original synapse data can be referenced after sending without requiring decompression.
        """
        try:
            if engine:
                self.compression_engine = engine
            if not self.compressed:
                compressed = self.model_copy()
                if compressed.books != {}:
                    if not compressed_books:
                        compressed_books = compress({bookId : book.model_dump(mode='json') for bookId, book in self.books.items()}, level, self.compression_engine)
                    payload = {
                        "accounts" : {accountId : {bookId : account.model_dump(mode='json') for bookId, account in accounts.items()} for accountId, accounts in self.accounts.items()},
                        "notices" : {agentId : [notice.model_dump(mode='json') for notice in notices] for agentId, notices in self.notices.items()},
                        "config" : self.config.model_dump(mode='json'),
                        "response" : compressed.response.model_dump(mode='json') if self.response else None
                    }
                    compressed.compressed = {
                        "books" : compressed_books,
                        "payload" : compress(payload, level, self.compression_engine)
                    }
                    compressed.books = None
                    compressed.accounts = None
                    compressed.notices = None
                    compressed.config = None
                    compressed.response = None
                return compressed
            else:
                return self
        except Exception as ex:
            bt.logging.error(f"Failed to compress {self.name} synapse data! {ex}")
            return None

    def decompress(self):
        """
        Method to decompress large synapse fields after transmission over the network.

        Note this method DOES modify the synapse in place, so that the synapse can be used normally after decompression.
        """
        try:
            match self.compression_engine:
                case "zlib":
                    decompressor = zlib.decompress
                case "lz4":
                    decompressor = lz4.frame.decompress
                case _:
                    raise Exception(f"Invalid compression engine `{self.compression_engine}` - allowed values are `zlib` or `lz4`")
            if self.compressed:
                if isinstance(self.compressed, str):
                    decompressed = msgspec.json.decode(decompressor(pybase64.b64decode(self.compressed)))
                else:
                    decompressed_payload = msgspec.json.decode(decompressor(pybase64.b64decode(self.compressed['payload'])))             
                    decompressed ={"books" : msgspec.json.decode(decompressor(pybase64.b64decode(self.compressed['books'])))} | decompressed_payload
                self.compressed = None
                self.books = decompressed['books']
                self.accounts = decompressed['accounts']
                self.notices = decompressed['notices']
                self.config = decompressed['config']
                self.response = decompressed['response']
            return self
        except Exception as ex:
            bt.logging.error(f"Failed to decompress {self.name} synapse data! {ex}")
            return None